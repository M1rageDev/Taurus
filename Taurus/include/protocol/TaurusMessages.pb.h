// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: TaurusMessages.proto
// Protobuf C++ Version: 5.29.5

#ifndef TaurusMessages_2eproto_2epb_2eh
#define TaurusMessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_TaurusMessages_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_TaurusMessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_TaurusMessages_2eproto;
namespace messages {
class ControllerStatus;
struct ControllerStatusDefaultTypeInternal;
extern ControllerStatusDefaultTypeInternal _ControllerStatus_default_instance_;
class DriverMessage;
struct DriverMessageDefaultTypeInternal;
extern DriverMessageDefaultTypeInternal _DriverMessage_default_instance_;
class HapticEvent;
struct HapticEventDefaultTypeInternal;
extern HapticEventDefaultTypeInternal _HapticEvent_default_instance_;
class HapticMessage;
struct HapticMessageDefaultTypeInternal;
extern HapticMessageDefaultTypeInternal _HapticMessage_default_instance_;
class InputEvent;
struct InputEventDefaultTypeInternal;
extern InputEventDefaultTypeInternal _InputEvent_default_instance_;
class InputMessage;
struct InputMessageDefaultTypeInternal;
extern InputMessageDefaultTypeInternal _InputMessage_default_instance_;
class Orientation;
struct OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseMessage;
struct PoseMessageDefaultTypeInternal;
extern PoseMessageDefaultTypeInternal _PoseMessage_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class StatusMessage;
struct StatusMessageDefaultTypeInternal;
extern StatusMessageDefaultTypeInternal _StatusMessage_default_instance_;
class TaurusMessage;
struct TaurusMessageDefaultTypeInternal;
extern TaurusMessageDefaultTypeInternal _TaurusMessage_default_instance_;
class TrackerInfo;
struct TrackerInfoDefaultTypeInternal;
extern TrackerInfoDefaultTypeInternal _TrackerInfo_default_instance_;
class TrackersRequestAnswerMessage;
struct TrackersRequestAnswerMessageDefaultTypeInternal;
extern TrackersRequestAnswerMessageDefaultTypeInternal _TrackersRequestAnswerMessage_default_instance_;
class TrackersRequestMessage;
struct TrackersRequestMessageDefaultTypeInternal;
extern TrackersRequestMessageDefaultTypeInternal _TrackersRequestMessage_default_instance_;
}  // namespace messages
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace messages {
enum InputComponent : int {
  SYSTEM = 0,
  MOVE = 1,
  SQUARE = 2,
  CROSS = 3,
  TRIANGLE = 4,
  CIRCLE = 5,
  START = 6,
  SELECT = 7,
  TRIGGER = 8,
  InputComponent_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InputComponent_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InputComponent_IsValid(int value);
extern const uint32_t InputComponent_internal_data_[];
constexpr InputComponent InputComponent_MIN = static_cast<InputComponent>(0);
constexpr InputComponent InputComponent_MAX = static_cast<InputComponent>(8);
constexpr int InputComponent_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
InputComponent_descriptor();
template <typename T>
const std::string& InputComponent_Name(T value) {
  static_assert(std::is_same<T, InputComponent>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InputComponent_Name().");
  return InputComponent_Name(static_cast<InputComponent>(value));
}
template <>
inline const std::string& InputComponent_Name(InputComponent value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InputComponent_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool InputComponent_Parse(absl::string_view name, InputComponent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputComponent>(
      InputComponent_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TrackersRequestMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.TrackersRequestMessage) */ {
 public:
  inline TrackersRequestMessage() : TrackersRequestMessage(nullptr) {}
  ~TrackersRequestMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackersRequestMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackersRequestMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackersRequestMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrackersRequestMessage(const TrackersRequestMessage& from) : TrackersRequestMessage(nullptr, from) {}
  inline TrackersRequestMessage(TrackersRequestMessage&& from) noexcept
      : TrackersRequestMessage(nullptr, std::move(from)) {}
  inline TrackersRequestMessage& operator=(const TrackersRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackersRequestMessage& operator=(TrackersRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackersRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackersRequestMessage* internal_default_instance() {
    return reinterpret_cast<const TrackersRequestMessage*>(
        &_TrackersRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TrackersRequestMessage& a, TrackersRequestMessage& b) { a.Swap(&b); }
  inline void Swap(TrackersRequestMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackersRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackersRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackersRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackersRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackersRequestMessage& from) { TrackersRequestMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackersRequestMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.TrackersRequestMessage"; }

 protected:
  explicit TrackersRequestMessage(::google::protobuf::Arena* arena);
  TrackersRequestMessage(::google::protobuf::Arena* arena, const TrackersRequestMessage& from);
  TrackersRequestMessage(::google::protobuf::Arena* arena, TrackersRequestMessage&& from) noexcept
      : TrackersRequestMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlaceholderFieldNumber = 1,
  };
  // bool placeholder = 1;
  void clear_placeholder() ;
  bool placeholder() const;
  void set_placeholder(bool value);

  private:
  bool _internal_placeholder() const;
  void _internal_set_placeholder(bool value);

  public:
  // @@protoc_insertion_point(class_scope:messages.TrackersRequestMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrackersRequestMessage& from_msg);
    bool placeholder_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class Position final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Position* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Position));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Position(
      ::google::protobuf::internal::ConstantInitialized);

  inline Position(const Position& from) : Position(nullptr, from) {}
  inline Position(Position&& from) noexcept
      : Position(nullptr, std::move(from)) {}
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
        &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Position& a, Position& b) { a.Swap(&b); }
  inline void Swap(Position* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Position>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Position& from) { Position::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Position* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.Position"; }

 protected:
  explicit Position(::google::protobuf::Arena* arena);
  Position(::google::protobuf::Arena* arena, const Position& from);
  Position(::google::protobuf::Arena* arena, Position&& from) noexcept
      : Position(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:messages.Position)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Position& from_msg);
    float x_;
    float y_;
    float z_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class Orientation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.Orientation) */ {
 public:
  inline Orientation() : Orientation(nullptr) {}
  ~Orientation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Orientation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Orientation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Orientation(const Orientation& from) : Orientation(nullptr, from) {}
  inline Orientation(Orientation&& from) noexcept
      : Orientation(nullptr, std::move(from)) {}
  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation& operator=(Orientation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
        &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Orientation& a, Orientation& b) { a.Swap(&b); }
  inline void Swap(Orientation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Orientation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Orientation& from) { Orientation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Orientation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.Orientation"; }

 protected:
  explicit Orientation(::google::protobuf::Arena* arena);
  Orientation(::google::protobuf::Arena* arena, const Orientation& from);
  Orientation(::google::protobuf::Arena* arena, Orientation&& from) noexcept
      : Orientation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // float w = 4;
  void clear_w() ;
  float w() const;
  void set_w(float value);

  private:
  float _internal_w() const;
  void _internal_set_w(float value);

  public:
  // @@protoc_insertion_point(class_scope:messages.Orientation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Orientation& from_msg);
    float x_;
    float y_;
    float z_;
    float w_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class InputEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.InputEvent) */ {
 public:
  inline InputEvent() : InputEvent(nullptr) {}
  ~InputEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline InputEvent(const InputEvent& from) : InputEvent(nullptr, from) {}
  inline InputEvent(InputEvent&& from) noexcept
      : InputEvent(nullptr, std::move(from)) {}
  inline InputEvent& operator=(const InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputEvent& operator=(InputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputEvent* internal_default_instance() {
    return reinterpret_cast<const InputEvent*>(
        &_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(InputEvent& a, InputEvent& b) { a.Swap(&b); }
  inline void Swap(InputEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputEvent& from) { InputEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.InputEvent"; }

 protected:
  explicit InputEvent(::google::protobuf::Arena* arena);
  InputEvent(::google::protobuf::Arena* arena, const InputEvent& from);
  InputEvent(::google::protobuf::Arena* arena, InputEvent&& from) noexcept
      : InputEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .messages.InputComponent component = 1;
  void clear_component() ;
  ::messages::InputComponent component() const;
  void set_component(::messages::InputComponent value);

  private:
  ::messages::InputComponent _internal_component() const;
  void _internal_set_component(::messages::InputComponent value);

  public:
  // float value = 2;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:messages.InputEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InputEvent& from_msg);
    int component_;
    float value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class HapticEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.HapticEvent) */ {
 public:
  inline HapticEvent() : HapticEvent(nullptr) {}
  ~HapticEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HapticEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HapticEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HapticEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline HapticEvent(const HapticEvent& from) : HapticEvent(nullptr, from) {}
  inline HapticEvent(HapticEvent&& from) noexcept
      : HapticEvent(nullptr, std::move(from)) {}
  inline HapticEvent& operator=(const HapticEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HapticEvent& operator=(HapticEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HapticEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HapticEvent* internal_default_instance() {
    return reinterpret_cast<const HapticEvent*>(
        &_HapticEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HapticEvent& a, HapticEvent& b) { a.Swap(&b); }
  inline void Swap(HapticEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HapticEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HapticEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HapticEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HapticEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HapticEvent& from) { HapticEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HapticEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.HapticEvent"; }

 protected:
  explicit HapticEvent(::google::protobuf::Arena* arena);
  HapticEvent(::google::protobuf::Arena* arena, const HapticEvent& from);
  HapticEvent(::google::protobuf::Arena* arena, HapticEvent&& from) noexcept
      : HapticEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDurationFieldNumber = 1,
    kFrequencyFieldNumber = 2,
    kAmplitudeFieldNumber = 3,
  };
  // float duration = 1;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // float frequency = 2;
  void clear_frequency() ;
  float frequency() const;
  void set_frequency(float value);

  private:
  float _internal_frequency() const;
  void _internal_set_frequency(float value);

  public:
  // float amplitude = 3;
  void clear_amplitude() ;
  float amplitude() const;
  void set_amplitude(float value);

  private:
  float _internal_amplitude() const;
  void _internal_set_amplitude(float value);

  public:
  // @@protoc_insertion_point(class_scope:messages.HapticEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HapticEvent& from_msg);
    float duration_;
    float frequency_;
    float amplitude_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class ControllerStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.ControllerStatus) */ {
 public:
  inline ControllerStatus() : ControllerStatus(nullptr) {}
  ~ControllerStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControllerStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControllerStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ControllerStatus(const ControllerStatus& from) : ControllerStatus(nullptr, from) {}
  inline ControllerStatus(ControllerStatus&& from) noexcept
      : ControllerStatus(nullptr, std::move(from)) {}
  inline ControllerStatus& operator=(const ControllerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerStatus& operator=(ControllerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerStatus* internal_default_instance() {
    return reinterpret_cast<const ControllerStatus*>(
        &_ControllerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ControllerStatus& a, ControllerStatus& b) { a.Swap(&b); }
  inline void Swap(ControllerStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ControllerStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControllerStatus& from) { ControllerStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControllerStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.ControllerStatus"; }

 protected:
  explicit ControllerStatus(::google::protobuf::Arena* arena);
  ControllerStatus(::google::protobuf::Arena* arena, const ControllerStatus& from);
  ControllerStatus(::google::protobuf::Arena* arena, ControllerStatus&& from) noexcept
      : ControllerStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsConnectedFieldNumber = 1,
    kIsTrackingFieldNumber = 2,
    kIsChargingFieldNumber = 3,
    kBatteryPercentFieldNumber = 4,
  };
  // bool is_connected = 1;
  void clear_is_connected() ;
  bool is_connected() const;
  void set_is_connected(bool value);

  private:
  bool _internal_is_connected() const;
  void _internal_set_is_connected(bool value);

  public:
  // bool is_tracking = 2;
  void clear_is_tracking() ;
  bool is_tracking() const;
  void set_is_tracking(bool value);

  private:
  bool _internal_is_tracking() const;
  void _internal_set_is_tracking(bool value);

  public:
  // bool is_charging = 3;
  void clear_is_charging() ;
  bool is_charging() const;
  void set_is_charging(bool value);

  private:
  bool _internal_is_charging() const;
  void _internal_set_is_charging(bool value);

  public:
  // int32 battery_percent = 4;
  void clear_battery_percent() ;
  ::int32_t battery_percent() const;
  void set_battery_percent(::int32_t value);

  private:
  ::int32_t _internal_battery_percent() const;
  void _internal_set_battery_percent(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:messages.ControllerStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ControllerStatus& from_msg);
    bool is_connected_;
    bool is_tracking_;
    bool is_charging_;
    ::int32_t battery_percent_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class StatusMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.StatusMessage) */ {
 public:
  inline StatusMessage() : StatusMessage(nullptr) {}
  ~StatusMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StatusMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StatusMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatusMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatusMessage(const StatusMessage& from) : StatusMessage(nullptr, from) {}
  inline StatusMessage(StatusMessage&& from) noexcept
      : StatusMessage(nullptr, std::move(from)) {}
  inline StatusMessage& operator=(const StatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusMessage& operator=(StatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusMessage* internal_default_instance() {
    return reinterpret_cast<const StatusMessage*>(
        &_StatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(StatusMessage& a, StatusMessage& b) { a.Swap(&b); }
  inline void Swap(StatusMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StatusMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatusMessage& from) { StatusMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StatusMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.StatusMessage"; }

 protected:
  explicit StatusMessage(::google::protobuf::Arena* arena);
  StatusMessage(::google::protobuf::Arena* arena, const StatusMessage& from);
  StatusMessage(::google::protobuf::Arena* arena, StatusMessage&& from) noexcept
      : StatusMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .messages.ControllerStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::messages::ControllerStatus& status() const;
  PROTOBUF_NODISCARD ::messages::ControllerStatus* release_status();
  ::messages::ControllerStatus* mutable_status();
  void set_allocated_status(::messages::ControllerStatus* value);
  void unsafe_arena_set_allocated_status(::messages::ControllerStatus* value);
  ::messages::ControllerStatus* unsafe_arena_release_status();

  private:
  const ::messages::ControllerStatus& _internal_status() const;
  ::messages::ControllerStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:messages.StatusMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatusMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::messages::ControllerStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class Pose final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pose* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pose));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pose(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pose(const Pose& from) : Pose(nullptr, from) {}
  inline Pose(Pose&& from) noexcept
      : Pose(nullptr, std::move(from)) {}
  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
        &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Pose& a, Pose& b) { a.Swap(&b); }
  inline void Swap(Pose* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pose>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pose& from) { Pose::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pose* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.Pose"; }

 protected:
  explicit Pose(::google::protobuf::Arena* arena);
  Pose(::google::protobuf::Arena* arena, const Pose& from);
  Pose(::google::protobuf::Arena* arena, Pose&& from) noexcept
      : Pose(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // .messages.Position position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::messages::Position& position() const;
  PROTOBUF_NODISCARD ::messages::Position* release_position();
  ::messages::Position* mutable_position();
  void set_allocated_position(::messages::Position* value);
  void unsafe_arena_set_allocated_position(::messages::Position* value);
  ::messages::Position* unsafe_arena_release_position();

  private:
  const ::messages::Position& _internal_position() const;
  ::messages::Position* _internal_mutable_position();

  public:
  // .messages.Orientation orientation = 2;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::messages::Orientation& orientation() const;
  PROTOBUF_NODISCARD ::messages::Orientation* release_orientation();
  ::messages::Orientation* mutable_orientation();
  void set_allocated_orientation(::messages::Orientation* value);
  void unsafe_arena_set_allocated_orientation(::messages::Orientation* value);
  ::messages::Orientation* unsafe_arena_release_orientation();

  private:
  const ::messages::Orientation& _internal_orientation() const;
  ::messages::Orientation* _internal_mutable_orientation();

  public:
  // @@protoc_insertion_point(class_scope:messages.Pose)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pose& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::messages::Position* position_;
    ::messages::Orientation* orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class InputMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.InputMessage) */ {
 public:
  inline InputMessage() : InputMessage(nullptr) {}
  ~InputMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline InputMessage(const InputMessage& from) : InputMessage(nullptr, from) {}
  inline InputMessage(InputMessage&& from) noexcept
      : InputMessage(nullptr, std::move(from)) {}
  inline InputMessage& operator=(const InputMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputMessage& operator=(InputMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputMessage* internal_default_instance() {
    return reinterpret_cast<const InputMessage*>(
        &_InputMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(InputMessage& a, InputMessage& b) { a.Swap(&b); }
  inline void Swap(InputMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputMessage& from) { InputMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.InputMessage"; }

 protected:
  explicit InputMessage(::google::protobuf::Arena* arena);
  InputMessage(::google::protobuf::Arena* arena, const InputMessage& from);
  InputMessage(::google::protobuf::Arena* arena, InputMessage&& from) noexcept
      : InputMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .messages.InputEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::messages::InputEvent* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField<::messages::InputEvent>* mutable_events();

  private:
  const ::google::protobuf::RepeatedPtrField<::messages::InputEvent>& _internal_events() const;
  ::google::protobuf::RepeatedPtrField<::messages::InputEvent>* _internal_mutable_events();
  public:
  const ::messages::InputEvent& events(int index) const;
  ::messages::InputEvent* add_events();
  const ::google::protobuf::RepeatedPtrField<::messages::InputEvent>& events() const;
  // @@protoc_insertion_point(class_scope:messages.InputMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InputMessage& from_msg);
    ::google::protobuf::RepeatedPtrField< ::messages::InputEvent > events_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class HapticMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.HapticMessage) */ {
 public:
  inline HapticMessage() : HapticMessage(nullptr) {}
  ~HapticMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HapticMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HapticMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HapticMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline HapticMessage(const HapticMessage& from) : HapticMessage(nullptr, from) {}
  inline HapticMessage(HapticMessage&& from) noexcept
      : HapticMessage(nullptr, std::move(from)) {}
  inline HapticMessage& operator=(const HapticMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HapticMessage& operator=(HapticMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HapticMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HapticMessage* internal_default_instance() {
    return reinterpret_cast<const HapticMessage*>(
        &_HapticMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(HapticMessage& a, HapticMessage& b) { a.Swap(&b); }
  inline void Swap(HapticMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HapticMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HapticMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HapticMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HapticMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HapticMessage& from) { HapticMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HapticMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.HapticMessage"; }

 protected:
  explicit HapticMessage(::google::protobuf::Arena* arena);
  HapticMessage(::google::protobuf::Arena* arena, const HapticMessage& from);
  HapticMessage(::google::protobuf::Arena* arena, HapticMessage&& from) noexcept
      : HapticMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventFieldNumber = 1,
  };
  // .messages.HapticEvent event = 1;
  bool has_event() const;
  void clear_event() ;
  const ::messages::HapticEvent& event() const;
  PROTOBUF_NODISCARD ::messages::HapticEvent* release_event();
  ::messages::HapticEvent* mutable_event();
  void set_allocated_event(::messages::HapticEvent* value);
  void unsafe_arena_set_allocated_event(::messages::HapticEvent* value);
  ::messages::HapticEvent* unsafe_arena_release_event();

  private:
  const ::messages::HapticEvent& _internal_event() const;
  ::messages::HapticEvent* _internal_mutable_event();

  public:
  // @@protoc_insertion_point(class_scope:messages.HapticMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HapticMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::messages::HapticEvent* event_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class TrackerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.TrackerInfo) */ {
 public:
  inline TrackerInfo() : TrackerInfo(nullptr) {}
  ~TrackerInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackerInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackerInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrackerInfo(const TrackerInfo& from) : TrackerInfo(nullptr, from) {}
  inline TrackerInfo(TrackerInfo&& from) noexcept
      : TrackerInfo(nullptr, std::move(from)) {}
  inline TrackerInfo& operator=(const TrackerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackerInfo& operator=(TrackerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackerInfo* internal_default_instance() {
    return reinterpret_cast<const TrackerInfo*>(
        &_TrackerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(TrackerInfo& a, TrackerInfo& b) { a.Swap(&b); }
  inline void Swap(TrackerInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackerInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackerInfo& from) { TrackerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackerInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.TrackerInfo"; }

 protected:
  explicit TrackerInfo(::google::protobuf::Arena* arena);
  TrackerInfo(::google::protobuf::Arena* arena, const TrackerInfo& from);
  TrackerInfo(::google::protobuf::Arena* arena, TrackerInfo&& from) noexcept
      : TrackerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoseFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .messages.Pose pose = 2;
  bool has_pose() const;
  void clear_pose() ;
  const ::messages::Pose& pose() const;
  PROTOBUF_NODISCARD ::messages::Pose* release_pose();
  ::messages::Pose* mutable_pose();
  void set_allocated_pose(::messages::Pose* value);
  void unsafe_arena_set_allocated_pose(::messages::Pose* value);
  ::messages::Pose* unsafe_arena_release_pose();

  private:
  const ::messages::Pose& _internal_pose() const;
  ::messages::Pose* _internal_mutable_pose();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:messages.TrackerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrackerInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::messages::Pose* pose_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class PoseMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.PoseMessage) */ {
 public:
  inline PoseMessage() : PoseMessage(nullptr) {}
  ~PoseMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PoseMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PoseMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PoseMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline PoseMessage(const PoseMessage& from) : PoseMessage(nullptr, from) {}
  inline PoseMessage(PoseMessage&& from) noexcept
      : PoseMessage(nullptr, std::move(from)) {}
  inline PoseMessage& operator=(const PoseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseMessage& operator=(PoseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoseMessage* internal_default_instance() {
    return reinterpret_cast<const PoseMessage*>(
        &_PoseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PoseMessage& a, PoseMessage& b) { a.Swap(&b); }
  inline void Swap(PoseMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoseMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PoseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PoseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PoseMessage& from) { PoseMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PoseMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.PoseMessage"; }

 protected:
  explicit PoseMessage(::google::protobuf::Arena* arena);
  PoseMessage(::google::protobuf::Arena* arena, const PoseMessage& from);
  PoseMessage(::google::protobuf::Arena* arena, PoseMessage&& from) noexcept
      : PoseMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPoseFieldNumber = 1,
  };
  // .messages.Pose pose = 1;
  bool has_pose() const;
  void clear_pose() ;
  const ::messages::Pose& pose() const;
  PROTOBUF_NODISCARD ::messages::Pose* release_pose();
  ::messages::Pose* mutable_pose();
  void set_allocated_pose(::messages::Pose* value);
  void unsafe_arena_set_allocated_pose(::messages::Pose* value);
  ::messages::Pose* unsafe_arena_release_pose();

  private:
  const ::messages::Pose& _internal_pose() const;
  ::messages::Pose* _internal_mutable_pose();

  public:
  // @@protoc_insertion_point(class_scope:messages.PoseMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PoseMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::messages::Pose* pose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class DriverMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.DriverMessage) */ {
 public:
  inline DriverMessage() : DriverMessage(nullptr) {}
  ~DriverMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DriverMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DriverMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DriverMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline DriverMessage(const DriverMessage& from) : DriverMessage(nullptr, from) {}
  inline DriverMessage(DriverMessage&& from) noexcept
      : DriverMessage(nullptr, std::move(from)) {}
  inline DriverMessage& operator=(const DriverMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriverMessage& operator=(DriverMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DriverMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kHapticMessage = 2,
    kTrackersRequestMessage = 3,
    MESSAGE_NOT_SET = 0,
  };
  static inline const DriverMessage* internal_default_instance() {
    return reinterpret_cast<const DriverMessage*>(
        &_DriverMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(DriverMessage& a, DriverMessage& b) { a.Swap(&b); }
  inline void Swap(DriverMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriverMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriverMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DriverMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DriverMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DriverMessage& from) { DriverMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DriverMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.DriverMessage"; }

 protected:
  explicit DriverMessage(::google::protobuf::Arena* arena);
  DriverMessage(::google::protobuf::Arena* arena, const DriverMessage& from);
  DriverMessage(::google::protobuf::Arena* arena, DriverMessage&& from) noexcept
      : DriverMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSerialFieldNumber = 1,
    kHapticMessageFieldNumber = 2,
    kTrackersRequestMessageFieldNumber = 3,
  };
  // string serial = 1;
  void clear_serial() ;
  const std::string& serial() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serial(Arg_&& arg, Args_... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* value);

  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(
      const std::string& value);
  std::string* _internal_mutable_serial();

  public:
  // .messages.HapticMessage haptic_message = 2;
  bool has_haptic_message() const;
  private:
  bool _internal_has_haptic_message() const;

  public:
  void clear_haptic_message() ;
  const ::messages::HapticMessage& haptic_message() const;
  PROTOBUF_NODISCARD ::messages::HapticMessage* release_haptic_message();
  ::messages::HapticMessage* mutable_haptic_message();
  void set_allocated_haptic_message(::messages::HapticMessage* value);
  void unsafe_arena_set_allocated_haptic_message(::messages::HapticMessage* value);
  ::messages::HapticMessage* unsafe_arena_release_haptic_message();

  private:
  const ::messages::HapticMessage& _internal_haptic_message() const;
  ::messages::HapticMessage* _internal_mutable_haptic_message();

  public:
  // .messages.TrackersRequestMessage trackers_request_message = 3;
  bool has_trackers_request_message() const;
  private:
  bool _internal_has_trackers_request_message() const;

  public:
  void clear_trackers_request_message() ;
  const ::messages::TrackersRequestMessage& trackers_request_message() const;
  PROTOBUF_NODISCARD ::messages::TrackersRequestMessage* release_trackers_request_message();
  ::messages::TrackersRequestMessage* mutable_trackers_request_message();
  void set_allocated_trackers_request_message(::messages::TrackersRequestMessage* value);
  void unsafe_arena_set_allocated_trackers_request_message(::messages::TrackersRequestMessage* value);
  ::messages::TrackersRequestMessage* unsafe_arena_release_trackers_request_message();

  private:
  const ::messages::TrackersRequestMessage& _internal_trackers_request_message() const;
  ::messages::TrackersRequestMessage* _internal_mutable_trackers_request_message();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:messages.DriverMessage)
 private:
  class _Internal;
  void set_has_haptic_message();
  void set_has_trackers_request_message();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DriverMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr serial_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::messages::HapticMessage* haptic_message_;
      ::messages::TrackersRequestMessage* trackers_request_message_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class TrackersRequestAnswerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.TrackersRequestAnswerMessage) */ {
 public:
  inline TrackersRequestAnswerMessage() : TrackersRequestAnswerMessage(nullptr) {}
  ~TrackersRequestAnswerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackersRequestAnswerMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackersRequestAnswerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackersRequestAnswerMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrackersRequestAnswerMessage(const TrackersRequestAnswerMessage& from) : TrackersRequestAnswerMessage(nullptr, from) {}
  inline TrackersRequestAnswerMessage(TrackersRequestAnswerMessage&& from) noexcept
      : TrackersRequestAnswerMessage(nullptr, std::move(from)) {}
  inline TrackersRequestAnswerMessage& operator=(const TrackersRequestAnswerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackersRequestAnswerMessage& operator=(TrackersRequestAnswerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackersRequestAnswerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackersRequestAnswerMessage* internal_default_instance() {
    return reinterpret_cast<const TrackersRequestAnswerMessage*>(
        &_TrackersRequestAnswerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(TrackersRequestAnswerMessage& a, TrackersRequestAnswerMessage& b) { a.Swap(&b); }
  inline void Swap(TrackersRequestAnswerMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackersRequestAnswerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackersRequestAnswerMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackersRequestAnswerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackersRequestAnswerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackersRequestAnswerMessage& from) { TrackersRequestAnswerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackersRequestAnswerMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.TrackersRequestAnswerMessage"; }

 protected:
  explicit TrackersRequestAnswerMessage(::google::protobuf::Arena* arena);
  TrackersRequestAnswerMessage(::google::protobuf::Arena* arena, const TrackersRequestAnswerMessage& from);
  TrackersRequestAnswerMessage(::google::protobuf::Arena* arena, TrackersRequestAnswerMessage&& from) noexcept
      : TrackersRequestAnswerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackersFieldNumber = 1,
  };
  // repeated .messages.TrackerInfo trackers = 1;
  int trackers_size() const;
  private:
  int _internal_trackers_size() const;

  public:
  void clear_trackers() ;
  ::messages::TrackerInfo* mutable_trackers(int index);
  ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>* mutable_trackers();

  private:
  const ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>& _internal_trackers() const;
  ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>* _internal_mutable_trackers();
  public:
  const ::messages::TrackerInfo& trackers(int index) const;
  ::messages::TrackerInfo* add_trackers();
  const ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>& trackers() const;
  // @@protoc_insertion_point(class_scope:messages.TrackersRequestAnswerMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrackersRequestAnswerMessage& from_msg);
    ::google::protobuf::RepeatedPtrField< ::messages::TrackerInfo > trackers_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};
// -------------------------------------------------------------------

class TaurusMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:messages.TaurusMessage) */ {
 public:
  inline TaurusMessage() : TaurusMessage(nullptr) {}
  ~TaurusMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaurusMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaurusMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaurusMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaurusMessage(const TaurusMessage& from) : TaurusMessage(nullptr, from) {}
  inline TaurusMessage(TaurusMessage&& from) noexcept
      : TaurusMessage(nullptr, std::move(from)) {}
  inline TaurusMessage& operator=(const TaurusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaurusMessage& operator=(TaurusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaurusMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kPoseMessage = 2,
    kInputMessage = 3,
    kStatusMessage = 4,
    kTrackersRequestAnswerMessage = 5,
    MESSAGE_NOT_SET = 0,
  };
  static inline const TaurusMessage* internal_default_instance() {
    return reinterpret_cast<const TaurusMessage*>(
        &_TaurusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TaurusMessage& a, TaurusMessage& b) { a.Swap(&b); }
  inline void Swap(TaurusMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaurusMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaurusMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaurusMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaurusMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaurusMessage& from) { TaurusMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaurusMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "messages.TaurusMessage"; }

 protected:
  explicit TaurusMessage(::google::protobuf::Arena* arena);
  TaurusMessage(::google::protobuf::Arena* arena, const TaurusMessage& from);
  TaurusMessage(::google::protobuf::Arena* arena, TaurusMessage&& from) noexcept
      : TaurusMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSerialFieldNumber = 1,
    kPoseMessageFieldNumber = 2,
    kInputMessageFieldNumber = 3,
    kStatusMessageFieldNumber = 4,
    kTrackersRequestAnswerMessageFieldNumber = 5,
  };
  // string serial = 1;
  void clear_serial() ;
  const std::string& serial() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serial(Arg_&& arg, Args_... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* value);

  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(
      const std::string& value);
  std::string* _internal_mutable_serial();

  public:
  // .messages.PoseMessage pose_message = 2;
  bool has_pose_message() const;
  private:
  bool _internal_has_pose_message() const;

  public:
  void clear_pose_message() ;
  const ::messages::PoseMessage& pose_message() const;
  PROTOBUF_NODISCARD ::messages::PoseMessage* release_pose_message();
  ::messages::PoseMessage* mutable_pose_message();
  void set_allocated_pose_message(::messages::PoseMessage* value);
  void unsafe_arena_set_allocated_pose_message(::messages::PoseMessage* value);
  ::messages::PoseMessage* unsafe_arena_release_pose_message();

  private:
  const ::messages::PoseMessage& _internal_pose_message() const;
  ::messages::PoseMessage* _internal_mutable_pose_message();

  public:
  // .messages.InputMessage input_message = 3;
  bool has_input_message() const;
  private:
  bool _internal_has_input_message() const;

  public:
  void clear_input_message() ;
  const ::messages::InputMessage& input_message() const;
  PROTOBUF_NODISCARD ::messages::InputMessage* release_input_message();
  ::messages::InputMessage* mutable_input_message();
  void set_allocated_input_message(::messages::InputMessage* value);
  void unsafe_arena_set_allocated_input_message(::messages::InputMessage* value);
  ::messages::InputMessage* unsafe_arena_release_input_message();

  private:
  const ::messages::InputMessage& _internal_input_message() const;
  ::messages::InputMessage* _internal_mutable_input_message();

  public:
  // .messages.StatusMessage status_message = 4;
  bool has_status_message() const;
  private:
  bool _internal_has_status_message() const;

  public:
  void clear_status_message() ;
  const ::messages::StatusMessage& status_message() const;
  PROTOBUF_NODISCARD ::messages::StatusMessage* release_status_message();
  ::messages::StatusMessage* mutable_status_message();
  void set_allocated_status_message(::messages::StatusMessage* value);
  void unsafe_arena_set_allocated_status_message(::messages::StatusMessage* value);
  ::messages::StatusMessage* unsafe_arena_release_status_message();

  private:
  const ::messages::StatusMessage& _internal_status_message() const;
  ::messages::StatusMessage* _internal_mutable_status_message();

  public:
  // .messages.TrackersRequestAnswerMessage trackers_request_answer_message = 5;
  bool has_trackers_request_answer_message() const;
  private:
  bool _internal_has_trackers_request_answer_message() const;

  public:
  void clear_trackers_request_answer_message() ;
  const ::messages::TrackersRequestAnswerMessage& trackers_request_answer_message() const;
  PROTOBUF_NODISCARD ::messages::TrackersRequestAnswerMessage* release_trackers_request_answer_message();
  ::messages::TrackersRequestAnswerMessage* mutable_trackers_request_answer_message();
  void set_allocated_trackers_request_answer_message(::messages::TrackersRequestAnswerMessage* value);
  void unsafe_arena_set_allocated_trackers_request_answer_message(::messages::TrackersRequestAnswerMessage* value);
  ::messages::TrackersRequestAnswerMessage* unsafe_arena_release_trackers_request_answer_message();

  private:
  const ::messages::TrackersRequestAnswerMessage& _internal_trackers_request_answer_message() const;
  ::messages::TrackersRequestAnswerMessage* _internal_mutable_trackers_request_answer_message();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:messages.TaurusMessage)
 private:
  class _Internal;
  void set_has_pose_message();
  void set_has_input_message();
  void set_has_status_message();
  void set_has_trackers_request_answer_message();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 4,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaurusMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr serial_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::messages::PoseMessage* pose_message_;
      ::messages::InputMessage* input_message_;
      ::messages::StatusMessage* status_message_;
      ::messages::TrackersRequestAnswerMessage* trackers_request_answer_message_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TaurusMessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:messages.Position.x)
  return _internal_x();
}
inline void Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:messages.Position.x)
}
inline float Position::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Position::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Position::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:messages.Position.y)
  return _internal_y();
}
inline void Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:messages.Position.y)
}
inline float Position::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Position::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Position::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:messages.Position.z)
  return _internal_z();
}
inline void Position::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:messages.Position.z)
}
inline float Position::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Position::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Orientation

// float x = 1;
inline void Orientation::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Orientation::x() const {
  // @@protoc_insertion_point(field_get:messages.Orientation.x)
  return _internal_x();
}
inline void Orientation::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:messages.Orientation.x)
}
inline float Orientation::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Orientation::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Orientation::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Orientation::y() const {
  // @@protoc_insertion_point(field_get:messages.Orientation.y)
  return _internal_y();
}
inline void Orientation::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:messages.Orientation.y)
}
inline float Orientation::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Orientation::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Orientation::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Orientation::z() const {
  // @@protoc_insertion_point(field_get:messages.Orientation.z)
  return _internal_z();
}
inline void Orientation::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:messages.Orientation.z)
}
inline float Orientation::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Orientation::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// float w = 4;
inline void Orientation::clear_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.w_ = 0;
}
inline float Orientation::w() const {
  // @@protoc_insertion_point(field_get:messages.Orientation.w)
  return _internal_w();
}
inline void Orientation::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:messages.Orientation.w)
}
inline float Orientation::_internal_w() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.w_;
}
inline void Orientation::_internal_set_w(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.w_ = value;
}

// -------------------------------------------------------------------

// Pose

// .messages.Position position = 1;
inline bool Pose::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Pose::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::messages::Position& Pose::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::messages::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::messages::Position&>(::messages::_Position_default_instance_);
}
inline const ::messages::Position& Pose::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(::messages::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::messages::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.Pose.position)
}
inline ::messages::Position* Pose::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::messages::Position* Pose::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.Pose.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::messages::Position* Pose::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::messages::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::messages::Position*>(p);
  }
  return _impl_.position_;
}
inline ::messages::Position* Pose::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::messages::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:messages.Pose.position)
  return _msg;
}
inline void Pose::set_allocated_position(::messages::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::messages::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:messages.Pose.position)
}

// .messages.Orientation orientation = 2;
inline bool Pose::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void Pose::clear_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::messages::Orientation& Pose::_internal_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::messages::Orientation* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::messages::Orientation&>(::messages::_Orientation_default_instance_);
}
inline const ::messages::Orientation& Pose::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.Pose.orientation)
  return _internal_orientation();
}
inline void Pose::unsafe_arena_set_allocated_orientation(::messages::Orientation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::messages::Orientation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.Pose.orientation)
}
inline ::messages::Orientation* Pose::release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::messages::Orientation* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::messages::Orientation* Pose::unsafe_arena_release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.Pose.orientation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::messages::Orientation* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::messages::Orientation* Pose::_internal_mutable_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::messages::Orientation>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::messages::Orientation*>(p);
  }
  return _impl_.orientation_;
}
inline ::messages::Orientation* Pose::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::messages::Orientation* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:messages.Pose.orientation)
  return _msg;
}
inline void Pose::set_allocated_orientation(::messages::Orientation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_ = reinterpret_cast<::messages::Orientation*>(value);
  // @@protoc_insertion_point(field_set_allocated:messages.Pose.orientation)
}

// -------------------------------------------------------------------

// InputEvent

// .messages.InputComponent component = 1;
inline void InputEvent::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_ = 0;
}
inline ::messages::InputComponent InputEvent::component() const {
  // @@protoc_insertion_point(field_get:messages.InputEvent.component)
  return _internal_component();
}
inline void InputEvent::set_component(::messages::InputComponent value) {
  _internal_set_component(value);
  // @@protoc_insertion_point(field_set:messages.InputEvent.component)
}
inline ::messages::InputComponent InputEvent::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::messages::InputComponent>(_impl_.component_);
}
inline void InputEvent::_internal_set_component(::messages::InputComponent value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_ = value;
}

// float value = 2;
inline void InputEvent::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline float InputEvent::value() const {
  // @@protoc_insertion_point(field_get:messages.InputEvent.value)
  return _internal_value();
}
inline void InputEvent::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:messages.InputEvent.value)
}
inline float InputEvent::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void InputEvent::_internal_set_value(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ControllerStatus

// bool is_connected = 1;
inline void ControllerStatus::clear_is_connected() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_connected_ = false;
}
inline bool ControllerStatus::is_connected() const {
  // @@protoc_insertion_point(field_get:messages.ControllerStatus.is_connected)
  return _internal_is_connected();
}
inline void ControllerStatus::set_is_connected(bool value) {
  _internal_set_is_connected(value);
  // @@protoc_insertion_point(field_set:messages.ControllerStatus.is_connected)
}
inline bool ControllerStatus::_internal_is_connected() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_connected_;
}
inline void ControllerStatus::_internal_set_is_connected(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_connected_ = value;
}

// bool is_tracking = 2;
inline void ControllerStatus::clear_is_tracking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_tracking_ = false;
}
inline bool ControllerStatus::is_tracking() const {
  // @@protoc_insertion_point(field_get:messages.ControllerStatus.is_tracking)
  return _internal_is_tracking();
}
inline void ControllerStatus::set_is_tracking(bool value) {
  _internal_set_is_tracking(value);
  // @@protoc_insertion_point(field_set:messages.ControllerStatus.is_tracking)
}
inline bool ControllerStatus::_internal_is_tracking() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_tracking_;
}
inline void ControllerStatus::_internal_set_is_tracking(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_tracking_ = value;
}

// bool is_charging = 3;
inline void ControllerStatus::clear_is_charging() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_charging_ = false;
}
inline bool ControllerStatus::is_charging() const {
  // @@protoc_insertion_point(field_get:messages.ControllerStatus.is_charging)
  return _internal_is_charging();
}
inline void ControllerStatus::set_is_charging(bool value) {
  _internal_set_is_charging(value);
  // @@protoc_insertion_point(field_set:messages.ControllerStatus.is_charging)
}
inline bool ControllerStatus::_internal_is_charging() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_charging_;
}
inline void ControllerStatus::_internal_set_is_charging(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_charging_ = value;
}

// int32 battery_percent = 4;
inline void ControllerStatus::clear_battery_percent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.battery_percent_ = 0;
}
inline ::int32_t ControllerStatus::battery_percent() const {
  // @@protoc_insertion_point(field_get:messages.ControllerStatus.battery_percent)
  return _internal_battery_percent();
}
inline void ControllerStatus::set_battery_percent(::int32_t value) {
  _internal_set_battery_percent(value);
  // @@protoc_insertion_point(field_set:messages.ControllerStatus.battery_percent)
}
inline ::int32_t ControllerStatus::_internal_battery_percent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.battery_percent_;
}
inline void ControllerStatus::_internal_set_battery_percent(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.battery_percent_ = value;
}

// -------------------------------------------------------------------

// HapticEvent

// float duration = 1;
inline void HapticEvent::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = 0;
}
inline float HapticEvent::duration() const {
  // @@protoc_insertion_point(field_get:messages.HapticEvent.duration)
  return _internal_duration();
}
inline void HapticEvent::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:messages.HapticEvent.duration)
}
inline float HapticEvent::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_;
}
inline void HapticEvent::_internal_set_duration(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = value;
}

// float frequency = 2;
inline void HapticEvent::clear_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_ = 0;
}
inline float HapticEvent::frequency() const {
  // @@protoc_insertion_point(field_get:messages.HapticEvent.frequency)
  return _internal_frequency();
}
inline void HapticEvent::set_frequency(float value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:messages.HapticEvent.frequency)
}
inline float HapticEvent::_internal_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frequency_;
}
inline void HapticEvent::_internal_set_frequency(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_ = value;
}

// float amplitude = 3;
inline void HapticEvent::clear_amplitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amplitude_ = 0;
}
inline float HapticEvent::amplitude() const {
  // @@protoc_insertion_point(field_get:messages.HapticEvent.amplitude)
  return _internal_amplitude();
}
inline void HapticEvent::set_amplitude(float value) {
  _internal_set_amplitude(value);
  // @@protoc_insertion_point(field_set:messages.HapticEvent.amplitude)
}
inline float HapticEvent::_internal_amplitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amplitude_;
}
inline void HapticEvent::_internal_set_amplitude(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amplitude_ = value;
}

// -------------------------------------------------------------------

// TrackerInfo

// int32 id = 1;
inline void TrackerInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t TrackerInfo::id() const {
  // @@protoc_insertion_point(field_get:messages.TrackerInfo.id)
  return _internal_id();
}
inline void TrackerInfo::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:messages.TrackerInfo.id)
}
inline ::int32_t TrackerInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void TrackerInfo::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .messages.Pose pose = 2;
inline bool TrackerInfo::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void TrackerInfo::clear_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::messages::Pose& TrackerInfo::_internal_pose() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::messages::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::messages::Pose&>(::messages::_Pose_default_instance_);
}
inline const ::messages::Pose& TrackerInfo::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TrackerInfo.pose)
  return _internal_pose();
}
inline void TrackerInfo::unsafe_arena_set_allocated_pose(::messages::Pose* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::messages::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.TrackerInfo.pose)
}
inline ::messages::Pose* TrackerInfo::release_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::messages::Pose* TrackerInfo::unsafe_arena_release_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.TrackerInfo.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::messages::Pose* TrackerInfo::_internal_mutable_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pose_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::messages::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::messages::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::messages::Pose* TrackerInfo::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::messages::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:messages.TrackerInfo.pose)
  return _msg;
}
inline void TrackerInfo::set_allocated_pose(::messages::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::messages::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:messages.TrackerInfo.pose)
}

// -------------------------------------------------------------------

// PoseMessage

// .messages.Pose pose = 1;
inline bool PoseMessage::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void PoseMessage::clear_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::messages::Pose& PoseMessage::_internal_pose() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::messages::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::messages::Pose&>(::messages::_Pose_default_instance_);
}
inline const ::messages::Pose& PoseMessage::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.PoseMessage.pose)
  return _internal_pose();
}
inline void PoseMessage::unsafe_arena_set_allocated_pose(::messages::Pose* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::messages::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.PoseMessage.pose)
}
inline ::messages::Pose* PoseMessage::release_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::messages::Pose* PoseMessage::unsafe_arena_release_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.PoseMessage.pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::messages::Pose* PoseMessage::_internal_mutable_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pose_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::messages::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::messages::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::messages::Pose* PoseMessage::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::messages::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:messages.PoseMessage.pose)
  return _msg;
}
inline void PoseMessage::set_allocated_pose(::messages::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pose_ = reinterpret_cast<::messages::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:messages.PoseMessage.pose)
}

// -------------------------------------------------------------------

// InputMessage

// repeated .messages.InputEvent events = 1;
inline int InputMessage::_internal_events_size() const {
  return _internal_events().size();
}
inline int InputMessage::events_size() const {
  return _internal_events_size();
}
inline void InputMessage::clear_events() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.events_.Clear();
}
inline ::messages::InputEvent* InputMessage::mutable_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:messages.InputMessage.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::messages::InputEvent>* InputMessage::mutable_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:messages.InputMessage.events)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_events();
}
inline const ::messages::InputEvent& InputMessage::events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.InputMessage.events)
  return _internal_events().Get(index);
}
inline ::messages::InputEvent* InputMessage::add_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::messages::InputEvent* _add = _internal_mutable_events()->Add();
  // @@protoc_insertion_point(field_add:messages.InputMessage.events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::messages::InputEvent>& InputMessage::events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:messages.InputMessage.events)
  return _internal_events();
}
inline const ::google::protobuf::RepeatedPtrField<::messages::InputEvent>&
InputMessage::_internal_events() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedPtrField<::messages::InputEvent>*
InputMessage::_internal_mutable_events() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.events_;
}

// -------------------------------------------------------------------

// StatusMessage

// .messages.ControllerStatus status = 1;
inline bool StatusMessage::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void StatusMessage::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::messages::ControllerStatus& StatusMessage::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::messages::ControllerStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::messages::ControllerStatus&>(::messages::_ControllerStatus_default_instance_);
}
inline const ::messages::ControllerStatus& StatusMessage::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.StatusMessage.status)
  return _internal_status();
}
inline void StatusMessage::unsafe_arena_set_allocated_status(::messages::ControllerStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::messages::ControllerStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.StatusMessage.status)
}
inline ::messages::ControllerStatus* StatusMessage::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::ControllerStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::messages::ControllerStatus* StatusMessage::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.StatusMessage.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::ControllerStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::messages::ControllerStatus* StatusMessage::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::messages::ControllerStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::messages::ControllerStatus*>(p);
  }
  return _impl_.status_;
}
inline ::messages::ControllerStatus* StatusMessage::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::messages::ControllerStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:messages.StatusMessage.status)
  return _msg;
}
inline void StatusMessage::set_allocated_status(::messages::ControllerStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::messages::ControllerStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:messages.StatusMessage.status)
}

// -------------------------------------------------------------------

// TrackersRequestAnswerMessage

// repeated .messages.TrackerInfo trackers = 1;
inline int TrackersRequestAnswerMessage::_internal_trackers_size() const {
  return _internal_trackers().size();
}
inline int TrackersRequestAnswerMessage::trackers_size() const {
  return _internal_trackers_size();
}
inline void TrackersRequestAnswerMessage::clear_trackers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trackers_.Clear();
}
inline ::messages::TrackerInfo* TrackersRequestAnswerMessage::mutable_trackers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:messages.TrackersRequestAnswerMessage.trackers)
  return _internal_mutable_trackers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>* TrackersRequestAnswerMessage::mutable_trackers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:messages.TrackersRequestAnswerMessage.trackers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_trackers();
}
inline const ::messages::TrackerInfo& TrackersRequestAnswerMessage::trackers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TrackersRequestAnswerMessage.trackers)
  return _internal_trackers().Get(index);
}
inline ::messages::TrackerInfo* TrackersRequestAnswerMessage::add_trackers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::messages::TrackerInfo* _add = _internal_mutable_trackers()->Add();
  // @@protoc_insertion_point(field_add:messages.TrackersRequestAnswerMessage.trackers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>& TrackersRequestAnswerMessage::trackers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:messages.TrackersRequestAnswerMessage.trackers)
  return _internal_trackers();
}
inline const ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>&
TrackersRequestAnswerMessage::_internal_trackers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trackers_;
}
inline ::google::protobuf::RepeatedPtrField<::messages::TrackerInfo>*
TrackersRequestAnswerMessage::_internal_mutable_trackers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.trackers_;
}

// -------------------------------------------------------------------

// TaurusMessage

// string serial = 1;
inline void TaurusMessage::clear_serial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.ClearToEmpty();
}
inline const std::string& TaurusMessage::serial() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TaurusMessage.serial)
  return _internal_serial();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaurusMessage::set_serial(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:messages.TaurusMessage.serial)
}
inline std::string* TaurusMessage::mutable_serial() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:messages.TaurusMessage.serial)
  return _s;
}
inline const std::string& TaurusMessage::_internal_serial() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.serial_.Get();
}
inline void TaurusMessage::_internal_set_serial(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.Set(value, GetArena());
}
inline std::string* TaurusMessage::_internal_mutable_serial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.serial_.Mutable( GetArena());
}
inline std::string* TaurusMessage::release_serial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.TaurusMessage.serial)
  return _impl_.serial_.Release();
}
inline void TaurusMessage::set_allocated_serial(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:messages.TaurusMessage.serial)
}

// .messages.PoseMessage pose_message = 2;
inline bool TaurusMessage::has_pose_message() const {
  return message_case() == kPoseMessage;
}
inline bool TaurusMessage::_internal_has_pose_message() const {
  return message_case() == kPoseMessage;
}
inline void TaurusMessage::set_has_pose_message() {
  _impl_._oneof_case_[0] = kPoseMessage;
}
inline void TaurusMessage::clear_pose_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPoseMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.pose_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.pose_message_);
    }
    clear_has_message();
  }
}
inline ::messages::PoseMessage* TaurusMessage::release_pose_message() {
  // @@protoc_insertion_point(field_release:messages.TaurusMessage.pose_message)
  if (message_case() == kPoseMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.pose_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pose_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messages::PoseMessage& TaurusMessage::_internal_pose_message() const {
  return message_case() == kPoseMessage ? *_impl_.message_.pose_message_ : reinterpret_cast<::messages::PoseMessage&>(::messages::_PoseMessage_default_instance_);
}
inline const ::messages::PoseMessage& TaurusMessage::pose_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TaurusMessage.pose_message)
  return _internal_pose_message();
}
inline ::messages::PoseMessage* TaurusMessage::unsafe_arena_release_pose_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messages.TaurusMessage.pose_message)
  if (message_case() == kPoseMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.pose_message_;
    _impl_.message_.pose_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaurusMessage::unsafe_arena_set_allocated_pose_message(::messages::PoseMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_pose_message();
    _impl_.message_.pose_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.TaurusMessage.pose_message)
}
inline ::messages::PoseMessage* TaurusMessage::_internal_mutable_pose_message() {
  if (message_case() != kPoseMessage) {
    clear_message();
    set_has_pose_message();
    _impl_.message_.pose_message_ =
        ::google::protobuf::Message::DefaultConstruct<::messages::PoseMessage>(GetArena());
  }
  return _impl_.message_.pose_message_;
}
inline ::messages::PoseMessage* TaurusMessage::mutable_pose_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::messages::PoseMessage* _msg = _internal_mutable_pose_message();
  // @@protoc_insertion_point(field_mutable:messages.TaurusMessage.pose_message)
  return _msg;
}

// .messages.InputMessage input_message = 3;
inline bool TaurusMessage::has_input_message() const {
  return message_case() == kInputMessage;
}
inline bool TaurusMessage::_internal_has_input_message() const {
  return message_case() == kInputMessage;
}
inline void TaurusMessage::set_has_input_message() {
  _impl_._oneof_case_[0] = kInputMessage;
}
inline void TaurusMessage::clear_input_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kInputMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.input_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.input_message_);
    }
    clear_has_message();
  }
}
inline ::messages::InputMessage* TaurusMessage::release_input_message() {
  // @@protoc_insertion_point(field_release:messages.TaurusMessage.input_message)
  if (message_case() == kInputMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.input_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.input_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messages::InputMessage& TaurusMessage::_internal_input_message() const {
  return message_case() == kInputMessage ? *_impl_.message_.input_message_ : reinterpret_cast<::messages::InputMessage&>(::messages::_InputMessage_default_instance_);
}
inline const ::messages::InputMessage& TaurusMessage::input_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TaurusMessage.input_message)
  return _internal_input_message();
}
inline ::messages::InputMessage* TaurusMessage::unsafe_arena_release_input_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messages.TaurusMessage.input_message)
  if (message_case() == kInputMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.input_message_;
    _impl_.message_.input_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaurusMessage::unsafe_arena_set_allocated_input_message(::messages::InputMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_input_message();
    _impl_.message_.input_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.TaurusMessage.input_message)
}
inline ::messages::InputMessage* TaurusMessage::_internal_mutable_input_message() {
  if (message_case() != kInputMessage) {
    clear_message();
    set_has_input_message();
    _impl_.message_.input_message_ =
        ::google::protobuf::Message::DefaultConstruct<::messages::InputMessage>(GetArena());
  }
  return _impl_.message_.input_message_;
}
inline ::messages::InputMessage* TaurusMessage::mutable_input_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::messages::InputMessage* _msg = _internal_mutable_input_message();
  // @@protoc_insertion_point(field_mutable:messages.TaurusMessage.input_message)
  return _msg;
}

// .messages.StatusMessage status_message = 4;
inline bool TaurusMessage::has_status_message() const {
  return message_case() == kStatusMessage;
}
inline bool TaurusMessage::_internal_has_status_message() const {
  return message_case() == kStatusMessage;
}
inline void TaurusMessage::set_has_status_message() {
  _impl_._oneof_case_[0] = kStatusMessage;
}
inline void TaurusMessage::clear_status_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kStatusMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.status_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.status_message_);
    }
    clear_has_message();
  }
}
inline ::messages::StatusMessage* TaurusMessage::release_status_message() {
  // @@protoc_insertion_point(field_release:messages.TaurusMessage.status_message)
  if (message_case() == kStatusMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.status_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.status_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messages::StatusMessage& TaurusMessage::_internal_status_message() const {
  return message_case() == kStatusMessage ? *_impl_.message_.status_message_ : reinterpret_cast<::messages::StatusMessage&>(::messages::_StatusMessage_default_instance_);
}
inline const ::messages::StatusMessage& TaurusMessage::status_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TaurusMessage.status_message)
  return _internal_status_message();
}
inline ::messages::StatusMessage* TaurusMessage::unsafe_arena_release_status_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messages.TaurusMessage.status_message)
  if (message_case() == kStatusMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.status_message_;
    _impl_.message_.status_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaurusMessage::unsafe_arena_set_allocated_status_message(::messages::StatusMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_status_message();
    _impl_.message_.status_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.TaurusMessage.status_message)
}
inline ::messages::StatusMessage* TaurusMessage::_internal_mutable_status_message() {
  if (message_case() != kStatusMessage) {
    clear_message();
    set_has_status_message();
    _impl_.message_.status_message_ =
        ::google::protobuf::Message::DefaultConstruct<::messages::StatusMessage>(GetArena());
  }
  return _impl_.message_.status_message_;
}
inline ::messages::StatusMessage* TaurusMessage::mutable_status_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::messages::StatusMessage* _msg = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:messages.TaurusMessage.status_message)
  return _msg;
}

// .messages.TrackersRequestAnswerMessage trackers_request_answer_message = 5;
inline bool TaurusMessage::has_trackers_request_answer_message() const {
  return message_case() == kTrackersRequestAnswerMessage;
}
inline bool TaurusMessage::_internal_has_trackers_request_answer_message() const {
  return message_case() == kTrackersRequestAnswerMessage;
}
inline void TaurusMessage::set_has_trackers_request_answer_message() {
  _impl_._oneof_case_[0] = kTrackersRequestAnswerMessage;
}
inline void TaurusMessage::clear_trackers_request_answer_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrackersRequestAnswerMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.trackers_request_answer_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.trackers_request_answer_message_);
    }
    clear_has_message();
  }
}
inline ::messages::TrackersRequestAnswerMessage* TaurusMessage::release_trackers_request_answer_message() {
  // @@protoc_insertion_point(field_release:messages.TaurusMessage.trackers_request_answer_message)
  if (message_case() == kTrackersRequestAnswerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.trackers_request_answer_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.trackers_request_answer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messages::TrackersRequestAnswerMessage& TaurusMessage::_internal_trackers_request_answer_message() const {
  return message_case() == kTrackersRequestAnswerMessage ? *_impl_.message_.trackers_request_answer_message_ : reinterpret_cast<::messages::TrackersRequestAnswerMessage&>(::messages::_TrackersRequestAnswerMessage_default_instance_);
}
inline const ::messages::TrackersRequestAnswerMessage& TaurusMessage::trackers_request_answer_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.TaurusMessage.trackers_request_answer_message)
  return _internal_trackers_request_answer_message();
}
inline ::messages::TrackersRequestAnswerMessage* TaurusMessage::unsafe_arena_release_trackers_request_answer_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messages.TaurusMessage.trackers_request_answer_message)
  if (message_case() == kTrackersRequestAnswerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.trackers_request_answer_message_;
    _impl_.message_.trackers_request_answer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaurusMessage::unsafe_arena_set_allocated_trackers_request_answer_message(::messages::TrackersRequestAnswerMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_trackers_request_answer_message();
    _impl_.message_.trackers_request_answer_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.TaurusMessage.trackers_request_answer_message)
}
inline ::messages::TrackersRequestAnswerMessage* TaurusMessage::_internal_mutable_trackers_request_answer_message() {
  if (message_case() != kTrackersRequestAnswerMessage) {
    clear_message();
    set_has_trackers_request_answer_message();
    _impl_.message_.trackers_request_answer_message_ =
        ::google::protobuf::Message::DefaultConstruct<::messages::TrackersRequestAnswerMessage>(GetArena());
  }
  return _impl_.message_.trackers_request_answer_message_;
}
inline ::messages::TrackersRequestAnswerMessage* TaurusMessage::mutable_trackers_request_answer_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::messages::TrackersRequestAnswerMessage* _msg = _internal_mutable_trackers_request_answer_message();
  // @@protoc_insertion_point(field_mutable:messages.TaurusMessage.trackers_request_answer_message)
  return _msg;
}

inline bool TaurusMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void TaurusMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline TaurusMessage::MessageCase TaurusMessage::message_case() const {
  return TaurusMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HapticMessage

// .messages.HapticEvent event = 1;
inline bool HapticMessage::has_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.event_ != nullptr);
  return value;
}
inline void HapticMessage::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.event_ != nullptr) _impl_.event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::messages::HapticEvent& HapticMessage::_internal_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::messages::HapticEvent* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::messages::HapticEvent&>(::messages::_HapticEvent_default_instance_);
}
inline const ::messages::HapticEvent& HapticMessage::event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.HapticMessage.event)
  return _internal_event();
}
inline void HapticMessage::unsafe_arena_set_allocated_event(::messages::HapticEvent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = reinterpret_cast<::messages::HapticEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.HapticMessage.event)
}
inline ::messages::HapticEvent* HapticMessage::release_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::HapticEvent* released = _impl_.event_;
  _impl_.event_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::messages::HapticEvent* HapticMessage::unsafe_arena_release_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.HapticMessage.event)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::messages::HapticEvent* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::messages::HapticEvent* HapticMessage::_internal_mutable_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.event_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::messages::HapticEvent>(GetArena());
    _impl_.event_ = reinterpret_cast<::messages::HapticEvent*>(p);
  }
  return _impl_.event_;
}
inline ::messages::HapticEvent* HapticMessage::mutable_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::messages::HapticEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:messages.HapticMessage.event)
  return _msg;
}
inline void HapticMessage::set_allocated_event(::messages::HapticEvent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.event_ = reinterpret_cast<::messages::HapticEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:messages.HapticMessage.event)
}

// -------------------------------------------------------------------

// TrackersRequestMessage

// bool placeholder = 1;
inline void TrackersRequestMessage::clear_placeholder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.placeholder_ = false;
}
inline bool TrackersRequestMessage::placeholder() const {
  // @@protoc_insertion_point(field_get:messages.TrackersRequestMessage.placeholder)
  return _internal_placeholder();
}
inline void TrackersRequestMessage::set_placeholder(bool value) {
  _internal_set_placeholder(value);
  // @@protoc_insertion_point(field_set:messages.TrackersRequestMessage.placeholder)
}
inline bool TrackersRequestMessage::_internal_placeholder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.placeholder_;
}
inline void TrackersRequestMessage::_internal_set_placeholder(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.placeholder_ = value;
}

// -------------------------------------------------------------------

// DriverMessage

// string serial = 1;
inline void DriverMessage::clear_serial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.ClearToEmpty();
}
inline const std::string& DriverMessage::serial() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.DriverMessage.serial)
  return _internal_serial();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DriverMessage::set_serial(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:messages.DriverMessage.serial)
}
inline std::string* DriverMessage::mutable_serial() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:messages.DriverMessage.serial)
  return _s;
}
inline const std::string& DriverMessage::_internal_serial() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.serial_.Get();
}
inline void DriverMessage::_internal_set_serial(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.Set(value, GetArena());
}
inline std::string* DriverMessage::_internal_mutable_serial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.serial_.Mutable( GetArena());
}
inline std::string* DriverMessage::release_serial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:messages.DriverMessage.serial)
  return _impl_.serial_.Release();
}
inline void DriverMessage::set_allocated_serial(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:messages.DriverMessage.serial)
}

// .messages.HapticMessage haptic_message = 2;
inline bool DriverMessage::has_haptic_message() const {
  return message_case() == kHapticMessage;
}
inline bool DriverMessage::_internal_has_haptic_message() const {
  return message_case() == kHapticMessage;
}
inline void DriverMessage::set_has_haptic_message() {
  _impl_._oneof_case_[0] = kHapticMessage;
}
inline void DriverMessage::clear_haptic_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kHapticMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.haptic_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.haptic_message_);
    }
    clear_has_message();
  }
}
inline ::messages::HapticMessage* DriverMessage::release_haptic_message() {
  // @@protoc_insertion_point(field_release:messages.DriverMessage.haptic_message)
  if (message_case() == kHapticMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.haptic_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.haptic_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messages::HapticMessage& DriverMessage::_internal_haptic_message() const {
  return message_case() == kHapticMessage ? *_impl_.message_.haptic_message_ : reinterpret_cast<::messages::HapticMessage&>(::messages::_HapticMessage_default_instance_);
}
inline const ::messages::HapticMessage& DriverMessage::haptic_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.DriverMessage.haptic_message)
  return _internal_haptic_message();
}
inline ::messages::HapticMessage* DriverMessage::unsafe_arena_release_haptic_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messages.DriverMessage.haptic_message)
  if (message_case() == kHapticMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.haptic_message_;
    _impl_.message_.haptic_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DriverMessage::unsafe_arena_set_allocated_haptic_message(::messages::HapticMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_haptic_message();
    _impl_.message_.haptic_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.DriverMessage.haptic_message)
}
inline ::messages::HapticMessage* DriverMessage::_internal_mutable_haptic_message() {
  if (message_case() != kHapticMessage) {
    clear_message();
    set_has_haptic_message();
    _impl_.message_.haptic_message_ =
        ::google::protobuf::Message::DefaultConstruct<::messages::HapticMessage>(GetArena());
  }
  return _impl_.message_.haptic_message_;
}
inline ::messages::HapticMessage* DriverMessage::mutable_haptic_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::messages::HapticMessage* _msg = _internal_mutable_haptic_message();
  // @@protoc_insertion_point(field_mutable:messages.DriverMessage.haptic_message)
  return _msg;
}

// .messages.TrackersRequestMessage trackers_request_message = 3;
inline bool DriverMessage::has_trackers_request_message() const {
  return message_case() == kTrackersRequestMessage;
}
inline bool DriverMessage::_internal_has_trackers_request_message() const {
  return message_case() == kTrackersRequestMessage;
}
inline void DriverMessage::set_has_trackers_request_message() {
  _impl_._oneof_case_[0] = kTrackersRequestMessage;
}
inline void DriverMessage::clear_trackers_request_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrackersRequestMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.trackers_request_message_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.trackers_request_message_);
    }
    clear_has_message();
  }
}
inline ::messages::TrackersRequestMessage* DriverMessage::release_trackers_request_message() {
  // @@protoc_insertion_point(field_release:messages.DriverMessage.trackers_request_message)
  if (message_case() == kTrackersRequestMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.trackers_request_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.trackers_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messages::TrackersRequestMessage& DriverMessage::_internal_trackers_request_message() const {
  return message_case() == kTrackersRequestMessage ? *_impl_.message_.trackers_request_message_ : reinterpret_cast<::messages::TrackersRequestMessage&>(::messages::_TrackersRequestMessage_default_instance_);
}
inline const ::messages::TrackersRequestMessage& DriverMessage::trackers_request_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:messages.DriverMessage.trackers_request_message)
  return _internal_trackers_request_message();
}
inline ::messages::TrackersRequestMessage* DriverMessage::unsafe_arena_release_trackers_request_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messages.DriverMessage.trackers_request_message)
  if (message_case() == kTrackersRequestMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.trackers_request_message_;
    _impl_.message_.trackers_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DriverMessage::unsafe_arena_set_allocated_trackers_request_message(::messages::TrackersRequestMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_trackers_request_message();
    _impl_.message_.trackers_request_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messages.DriverMessage.trackers_request_message)
}
inline ::messages::TrackersRequestMessage* DriverMessage::_internal_mutable_trackers_request_message() {
  if (message_case() != kTrackersRequestMessage) {
    clear_message();
    set_has_trackers_request_message();
    _impl_.message_.trackers_request_message_ =
        ::google::protobuf::Message::DefaultConstruct<::messages::TrackersRequestMessage>(GetArena());
  }
  return _impl_.message_.trackers_request_message_;
}
inline ::messages::TrackersRequestMessage* DriverMessage::mutable_trackers_request_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::messages::TrackersRequestMessage* _msg = _internal_mutable_trackers_request_message();
  // @@protoc_insertion_point(field_mutable:messages.DriverMessage.trackers_request_message)
  return _msg;
}

inline bool DriverMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void DriverMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline DriverMessage::MessageCase DriverMessage::message_case() const {
  return DriverMessage::MessageCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace messages


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::messages::InputComponent> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::messages::InputComponent>() {
  return ::messages::InputComponent_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // TaurusMessages_2eproto_2epb_2eh
